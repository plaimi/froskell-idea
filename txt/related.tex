\subsection{Historical languages}
In this section we look at some existing solutions to the described problem,
and why they are not ideal. Let's start with some of the most popular
historical languages.

BASIC was authored to provide a programming language which would be easy to
learn for students without a rigorous mathematical background. It came about in
the '60s, designed for use with Darthmouth's timesharing system, and became
truly influential during the home computer revolution of the '70s. There have
been several versions of BASIC since the original; the most notable dialect
arguably being Microsoft's Visual Basic~\cite{time2014basic}.

Pascal was designed in 1971, partly as a simplified version of Algol, partly as
a language that encouraged structured programming. It was designed for
educational purposes, but evolved into a popular general-purpose programming
language~\cite{cantu2008essential}. The initial versions were criticised for
not being suitable for proper programming~\cite{kernighan1981pascal}. Several
versions and dialects of Pascal have since emerged~\cite{cantu2008essential},
that eliminate these problems.

Scheme is a Lisp programming language that was originally designed with
tutorial purposes in mind~\cite{sussman1998scheme}. It was used in the
influential book Structure and Interpretation of Computer Programs, which was
used at MIT to teach programming. The success of the book and the language
itself later lead to Scheme becoming a popular choice for introductory
programming courses at other universities too~\cite{felleisen2004structure}.

Logo is another Lisp programming language, made specifically for teaching
programming to children. A notable part of several Logo environments is the use
of a turtle avatar that moves around the screen and draws things. It is an
influential language which has seen a lot of adaptation since its
inception~\cite{logo2011whatislogo}.

None of the languages mentioned here solve any of the problems we have
identified. Furthermore, they are antiquated.

\subsection{Helium}

Helium~\cite{DBLP:conf/haskell/HeerenLI03} is a dialect of Haskell specifically
made for teaching. It focusses on good error messages. The implemented dialect
is not full Haskell since it does not include typeclasses. The work on Helium
might provide an inspiration for how to implement good error messages, but other
than that our work will extend on its functionality in several important ways.
Helium does not provide different levels of functionality, and requires a local
installation of full Haskell before it can be installed.

\subsection{Alice}
Alice is a language and environment designed exclusively to teach the concepts 
of object-oriented programming. It's a drag and drop environment in which the 
user makes animations by placing 3D models and scripting their behaviour by 
dragging and dropping control structures (loops, if-statements, and so 
on)~\cite{alice2015whatisalice}. One of the authors of this paper used Alice 
at university, and it was largely a negative experience. Alice has multiple 
shortcomings, including being proprietary, requiring a local install, only 
vaguely teaching object-oriented concepts and not being even remotely 
comparable to real life coding, having a thoroughly confusing user interface, 
and others. Alice falls short on all of our described problems.

\subsection{Mozart}
Mozart is an implementation of the Oz programming language. It is featured in 
the MIT textbook Concepts, Techniques, and Models of Computer Programming. 
Mozart consists of different subsets that are toggled as the user progresses 
in their learning~\cite{van2004concepts}. This is a core concept in our 
language, so we should familiarise ourselves with how Mozart works. Mozart 
does not, however, offer an online IDE with exercises etc. to make it easy to 
get started with. It moreover appears to not have received widespread usage.

\subsection{Online interactive IDEs not necessarily aimed at teaching}
There are several online interactive IDEs that we can learn from. They are not 
aimed at teaching and as such do not use informed and principled pedagogic 
methods to teach users programming, but rather act as supplementary resources 
when learning programming, providing the users with challenging tasks and 
often a game-ified environment with achievements, points and similar. In this 
section we discuss a few of them.

\url{http://www.codewars.com} lets users train on programming challenges, 
awarding points for doing so. Users can also vote on the best solutions to a 
task, and advanced users may author problems themselves. The site supports 
several programming languages, including Haskell, Clojure and Ruby. While not 
useful to learn programming per se, the challenges can act as neat supplements 
to someone who are learning to program. The IDE lets the user hack solutions 
in the browser (it includes emacs and vi input modes), and also evaluate 
whether the solution is correct via the browser. Several of the problems are 
well-authored with nice unit tests to help the user understand the problem at 
hand, and the IDE is pleasant to use for the most part.

\url{http://www.codingame.com/start} offers very visual game programming 
challenges. Once again there's an online IDE (with emacs and vi input modes), 
unit tests to guide the user, and in-browser verifying of the user's 
solutions. The site offers a huge selection of languages, including Haskell, C 
and Java. Interestingly the huge selection of languages seem to be a negative, 
in that they likely have a very limited API for their challenges, leading to 
all languages feeling slightly awkward in practice. The code you need to write 
is furthermore often far detached from "real world" code.

\url{http://www.playmycode.com} lets users hack \& play Ruby games, as well as 
share them with others. While testing we encountered bugs in the most popular 
games -- although the bugs could be related to the HTML "game player" rather 
than the games themselves, it's hard to tell. The IDE is severely handicapped 
as it does not offer emacs or vi bindings, but is at the very least 
functional. The site lets you upload graphics, and offers an online graphics 
editor as well. The latter would likely be avoided by experienced artists.

\url{http://elm-lang.org/try} lets you hack elm code interactively. You may 
compile the code and run it in the browser, you can even hot-swap code for a 
running program. The elm guys have been working on a time-travelling debugger 
in which you may turn back time in your running program, change the source, 
and resume the program, seeing previous paths being played out at the same 
time. It would be natural to assume that this will be featured in the IDE 
sometime soon. Note that this is just an online IDE, and not really anything 
else at all. There is, however, \url{http://share-elm.com/} for sharing elm 
code, and \url{http://elm-lang.org/Examples.elm} has a bunch of elm examples 
which you may open in the online IDE. Note that despite the elm chaps being 
clever enough to figure out time travel, they don't have emacs or vi bindings 
for their IDE. Lacking this is of course the nadir of IDE design.

\url{http://www.fpcomplete.com/page/project-build} offers an online IDE for
Haskell where you can create projects, compile them, and run them. It also
offers the use of libraries, and the IDE even offers vi and emacs bindings.  It
is a strong contender that shines with its low barrier to entry. It is, rather
unfortunately, proprietary, and seems to be aimed at businesses rather than
education. Our language and IDE have an edge since their implementations will
be free and open-source, and will be more suitable for teaching beginners,
having unlockable language features and good error messages.
